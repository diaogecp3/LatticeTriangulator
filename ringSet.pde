/******************************************************************************
 * Ring set processing.
 ******************************************************************************/


/*
 * TODO:
 *
 * 1. Use BFS to generate three-ring triangles.
 *    It is slower than naive method? Yes when n is small. No when n is large.
 *    How to make it fast? Combine BFS and heuristics, i.e. finding a good
      initial triangle.
 */


import java.util.Queue;

boolean debugFastCH = false;
int numFacesFastCH = 1;
int numStepsFastCH = 1;
int maxIterThreeRings = 100;
int maxIterOneRing = 100;

/*
 * 0: Naive method. Time: O(n^3). Space: O(1)
 * 1: Heuristic search. Time: O(n). Space: O(1)
 * 2: Breadth first search. Time: roughly O(min(3^d, n^3)) where d is the length
      from initial state to optimal state. Space: O(min(3^d, n^3))
 * 3: Breadth first search with heuristics. Time and space should be less than 2.
 */
int method3RT = 0;

class Debug3RTriInfo {  // debug info about three-ring-triangle generation
  int idr0, idr1, idr2;
  int idp0, idp1, idp2;
  int numSteps;
  int numFaces;
  Debug3RTriInfo() {
    idr0 = idr1 = idr2 = -1;
    idp0 = idp1 = idp2 = -1;
    numSteps = 0;
    numFaces = 0;
  }
}


class TriangleNode {
  Triangle tri;
  ArrayList<TriangleNode> children = null;
  TriangleNode(Triangle tri) {
    this.tri = tri;
  }

  boolean computeChildren(pt[][] rings, HashSet<Triangle> exploredSet) {
    assert rings.length == 3;
    int np = rings[0].length;
    pt[] ps = new pt[3];
    ps[0] = rings[0][tri.get(0)];
    ps[1] = rings[1][tri.get(1)];
    ps[2] = rings[2][tri.get(2)];
    vec normal = N(ps[0], ps[1], ps[2]);  // not necessarily unit vector
    boolean stable = true;
    pt p;
    vec v;
    children = new ArrayList<TriangleNode>();
    for (int r = 0; r < 3; ++r) {
      int[] idxs = new int[3];
      idxs[1] = tri.get((r + 1) % 3);
      idxs[2] = tri.get((r + 2) % 3);

      idxs[0] = (tri.get(r) - 1 + np) % np;
      p = rings[r][idxs[0]];
      v = V(ps[r], p);
      if (dot(normal, v) > 0) {
        if (stable == true) stable = false;
        Triangle tri = new Triangle(idxs[(3 - r) % 3], idxs[(4 - r) % 3], idxs[(5 - r) % 3]);
        if (!exploredSet.contains(tri)) {
          children.add(new TriangleNode(tri));
          exploredSet.add(tri);
        }
      }

      idxs[0] = (tri.get(r) + 1) % np;
      p = rings[r][idxs[0]];
      v = V(ps[r], p);
      if (dot(normal, v) > 0) {
        if (stable == true) stable = false;
        Triangle tri = new Triangle(idxs[(3 - r) % 3], idxs[(4 - r) % 3], idxs[(5 - r) % 3]);
        if (!exploredSet.contains(tri)) {
          children.add(new TriangleNode(tri));
          exploredSet.add(tri);
        }
      }
    }

    return stable;
  }
}



/*
 * RingSet class.
 *
 * A ring set is a set of rings (i.e. discritized cicles). We assume that these
 * rings lie on a sphere.
 */
class RingSet {
  pt c;  // the center of the sphere where the ring set lies
  float r;  // the radius of the sphere where the ring set lies
  int nc, np;  // number of rings/circles, and number of points on each ring
  boolean sameRadius;  // whether all rings have the same radius
  pt[] contacts;  // the intersections between the outward normals of rings and the sphere
  float[] radii;  // the radii of rings
  vec[] initDirs;  // the initial directions, one for each ring, used to generate the first point on ring

  pt[][] points;  // the generated points on rings
  pt[] centers;  // the centers of rings, one for each ring

  ArrayList<Triangle> triangles = null;  // triangle mesh with ring vertices
  ArrayList<Triangle> convexHullRef = null;  // convex hull generated by contacts
  ArrayList<Triangle> threeRingTriangles = null;

  Debug3RTriInfo debug3RTriInfo = new Debug3RTriInfo();  // for debug

  RingSet(pt c, float r) {
    this.c = c;
    this.r = r;
    sameRadius = false;
  }

  RingSet(pt c, float r, int nc, int np) {
    this.c = c;
    this.r = r;
    this.nc = nc;
    this.np = np;
    sameRadius = false;
  }

  RingSet(pt c, float r, int nc, int np, float rMax) {
    this.c = c;
    this.r = r;
    this.nc = nc;
    this.np = np;
    sameRadius = true;
    radii = new float[1];
    radii[0] = rMax;
  }

  void init() {
    if (!sameRadius) {
      radii = new float[nc];
      contacts = generateContactsAndRadii(c, r, nc, radii);
    } else {
      contacts = generateContacts(c, r, nc, radii[0]);
    }
    initDirs = generateInitDirs(c, contacts, nc);
  }

  void generatePoints(float attenuation) {
    centers = new pt[nc];
    if (!sameRadius) {
      float[] curRadii = new float[nc];
      for (int i = 0; i < nc; ++i) curRadii[i] = radii[i] * attenuation;
      points = generatePointsForCircles(contacts, curRadii, c, r, initDirs, nc,
                                        np, centers);
    } else {
      float curRadius = radii[0] * attenuation;
      points = generatePointsForCircles(contacts, curRadius, c, r, initDirs, nc,
                                        np, centers);
    }
  }

  void generateTriangleMesh() {
    triangles = generateConvexHull(points, nc, np);
  }

  void generateConvexHullRef() {
    assert contacts.length >= 3;
    convexHullRef = generateConvexHull(contacts, nc);
  }

  private int findStablePoint(pt[] points, int i, pt a, pt b, vec normal) {
    vec vn = normal;
    int d = dot(vn, V(points[i], points[(i + 1) % np])) > 0 ? 1 : -1;
    int inext = (i + d + np) % np;
    int iprev = (i - d + np) % np;
    int steps1 = 0;
    while ((dot(vn, V(points[i], points[inext])) > 0 ||
            dot(vn, V(points[i], points[iprev])) > 0) &&
            (steps1 < maxIterOneRing)) {
      if (debugFastCH &&
        debug3RTriInfo.numFaces == numFacesFastCH - 1 &&
        debug3RTriInfo.numSteps >= numStepsFastCH) break;
      iprev = i;
      i = inext;
      inext = (inext + d + np) % np;
      vn = N(points[i], a, b);
      if (debugFastCH) {
        debug3RTriInfo.numSteps++;
      }
      steps1++;
    }
    normal.setTo(vn);
    return i;
  }

  /* It seems that this function has bugs. */
  private Triangle generateThreeRingTriangleNaive(pt[] points0,
                                                  pt[] points1,
                                                  pt[] points2) {
    int i = 0, j = 0, k = 0;
    vec[] vs = new vec[6];
    for (i = 0; i < np; ++i) {
      pt pa = points0[i];
      vs[0] = V(pa, points0[(i-1+np)%np]);
      vs[1] = V(pa, points0[(i+1)%np]);
      for (j = 0; j < np; ++j) {
        pt pb = points1[j];
        vs[2] = V(pb, points1[(j-1+np)%np]);
        vs[3] = V(pb, points1[(j+1)%np]);
        for (k = 0; k < np; ++k) {
          pt pc = points2[k];
          vs[4] = V(pc, points2[(k-1+np)%np]);
          vs[5] = V(pc, points2[(k+1)%np]);
          vec normal = N(pa, pb, pc);
          boolean isValid = true;
          for (vec v : vs) {
            if (dot(normal, v) > 0) {
              isValid = false;
              break;
            }
          }
          if (isValid) return new Triangle(i, j, k);
        }
      }
    }
    println("return null even using naive method");
    return null;
  }

  /*
   * Generate a three-ring triangle given 3 rings using heuristic search.
   *
   * It may not converge when rings are large, rings have just a few points.
   *
   */
  private Triangle generateThreeRingTriangleHS(pt[] points0,
                                               pt[] points1,
                                               pt[] points2) {
    int i = 0, j = 0, k = 0;
    vec normal = N(points0[i], points1[j], points2[k]);
    if (debugFastCH) {
      debug3RTriInfo.idp0 = i;
      debug3RTriInfo.idp1 = j;
      debug3RTriInfo.idp2 = k;
      debug3RTriInfo.numSteps = 1;
    }
    int iter = 0;
    while (iter < maxIterThreeRings) {
      if (debugFastCH &&
          debug3RTriInfo.numFaces == numFacesFastCH - 1 &&
          debug3RTriInfo.numSteps >= numStepsFastCH) break;
      boolean noUpdate = true;
      /* Find ring A/B/C's stable point respectively. */
      int inew = findStablePoint(points0, i, points1[j], points2[k], normal);
      if (inew != i) {
        i = inew;
        if (noUpdate) noUpdate = false;
      }
      int jnew = findStablePoint(points1, j, points2[k], points0[i], normal);
      if (jnew != j) {
        j = jnew;
        if (noUpdate) noUpdate = false;
      }
      int knew = findStablePoint(points2, k, points0[i], points1[j], normal);
      if (knew != k) {
        k = knew;
        if (noUpdate) noUpdate = false;
      }
      if (noUpdate) break;  // break when stable
      iter++;
    }  // end while

    if (debugFastCH) {
      debug3RTriInfo.idp0 = i;
      debug3RTriInfo.idp1 = j;
      debug3RTriInfo.idp2 = k;
    }

    if (iter < maxIterThreeRings) {
      return new Triangle(i, j, k);
    } else {  // use backup method (could be naive or BFS)
      numBackup3RT++;
      //return generateThreeRingTriangleNaive(points0, points1, points2);
      return null;
    }
  }

  /*
   * Generate a three-ring triangle given 3 rings using BFS method.
   */
  private Triangle generateThreeRingTriangleBFS(pt[] points0,
                                                pt[] points1,
                                                pt[] points2) {
    pt[][] rings = new pt[3][];
    rings[0] = points0;
    rings[1] = points1;
    rings[2] = points2;
    Triangle tri = new Triangle(0, 0, 0);
    TriangleNode triNode = new TriangleNode(tri);
    Queue<TriangleNode> queue = new LinkedList<TriangleNode>();
    queue.add(triNode);
    HashSet<Triangle> set = new HashSet<Triangle>();
    set.add(tri);
    boolean stable = triNode.computeChildren(rings, set);
    if (stable) return tri;
    while (queue.size() > 0) {
      TriangleNode node = queue.poll();
      ArrayList<TriangleNode> children = node.children;
      int nc = children.size();
      for (int i = 0; i < nc; ++i) {
        TriangleNode child = children.get(i);
        stable = child.computeChildren(rings, set);
        if (stable) {
          if (set.size() > np * np * np) {
            println("size of explored set (bigger than np^3) = ", set.size());
          }
          return child.tri;
        }
        queue.add(child);
      }
    }
    println("cannot find stable three-ring triangle using BFS");
    return null;
  }

  void generateThreeRingTriangles() {
    int nt = convexHullRef.size();  // number of triangles of convex hull
    ArrayList<Triangle> threeRingTris = new ArrayList<Triangle>();
    debug3RTriInfo.numFaces = 0;
    for (int i = 0; i < nt; ++i) {
      if (debugFastCH && i >= numFacesFastCH) break;
      Triangle face = convexHullRef.get(i);

      Triangle t = null;
      switch (method3RT) {
        case 0:
          t = generateThreeRingTriangleNaive(points[face.a], points[face.b], points[face.c]);
          break;
        case 1:
          t = generateThreeRingTriangleHS(points[face.a], points[face.b], points[face.c]);
          break;
        case 2:
          t = generateThreeRingTriangleBFS(points[face.a], points[face.b], points[face.c]);
          break;
        default:
          t = generateThreeRingTriangleNaive(points[face.a], points[face.b], points[face.c]);
          break;
      }
      Triangle triangle = (t == null) ?
                          null :
                          new Triangle(face.a * np + t.a, face.b * np + t.b, face.c * np + t.c);
      threeRingTris.add(triangle);
      if (debugFastCH) {
        debug3RTriInfo.idr0 = face.a;
        debug3RTriInfo.idr1 = face.b;
        debug3RTriInfo.idr2 = face.c;
        debug3RTriInfo.numFaces++;
      }
    }  // end for
    this.threeRingTriangles = threeRingTris;
  }

  pt[][] get2DPointArray() {
    return points;
  }

  int getNumRings() {
    return nc;
  }

  int getNumPointsPerRing() {
    return np;
  }

  pt[] get1DPointArray() {
    if (points == null) return null;
    pt[] G = new pt[nc * np];
    int k = 0;
    for (int i = 0; i < nc; ++i) {
      for (int j = 0; j < np; ++j) {
        G[k++] = points[i][j];
      }
    }
    return G;
  }

  ArrayList<pt> get1DPointArrayList() {
    if (points == null) return null;
    ArrayList<pt> positions = new ArrayList<pt>();
    for (int i = 0; i < nc; ++i) {
      for (int j = 0; j < np; ++j) {
        positions.add(points[i][j]);
      }
    }
    return positions;
  }

  void showRings() {
    noStroke();
    fill(orange);
    for (int i = 0; i < nc; ++i) {
      show(centers[i], 1);
    }
    fill(green);
    for (int i = 0; i < nc; ++i) {
      arrow(centers[i], V(centers[i], points[i][0]), 2);
    }
    fill(blue);
    for (int i = 0; i < nc; ++i) {
      for (int j = 0; j < np; ++j) {
        show(points[i][j], 2);
      }
    }
    fill(cyan);
    for (int i = 0; i < nc; ++i) {
      for (int j = 0; j < np; ++j) {
        collar(points[i][j], V(points[i][j], points[i][(j + 1) % np]), 1, 1);
      }
    }
    return;
  }

  void showDebug3RTriInfo() {
    noStroke();
    fill(red, 150);
    show(contacts[debug3RTriInfo.idr0], 3);
    fill(green, 150);
    show(contacts[debug3RTriInfo.idr1], 3);
    fill(blue, 150);
    show(contacts[debug3RTriInfo.idr2], 3);
    fill(#BF6868, 200);  // light red
    show(points[debug3RTriInfo.idr0][debug3RTriInfo.idp0], 5);
    fill(#40935D, 200);  // light green
    show(points[debug3RTriInfo.idr1][debug3RTriInfo.idp1], 5);
    fill(#517EC9, 200);  // light blue
    show(points[debug3RTriInfo.idr2][debug3RTriInfo.idp2], 5);
  }

  void saveRings(String file) {
    String[] lines = new String[2 + 3 * nc];
    int i = 0;
    lines[i++] = str(nc);
    lines[i++] = str(np);
    for (int j = 0; j < nc; ++j) {
      lines[i++] = str(contacts[j].x) + "," + str(contacts[j].y) + "," +
                   str(contacts[j].z);
      lines[i++] = str(radii[j]);
      lines[i++] = str(initDirs[j].x) + "," + str(initDirs[j].y) + "," +
                   str(initDirs[j].z);
    }
    saveStrings(file, lines);
    return;
  }

  void loadRings(String file) {
    String[] lines = loadStrings(file);
    int i = 0;
    nc = int(lines[i++]);
    np = int(lines[i++]);
    println("loading:", file, "nc =", nc, "np =", np);
    contacts = new pt[nc];
    radii = new float[nc];
    initDirs = new vec[nc];
    for (int j = 0; j < nc; ++j) {
      float[] contact = float(split(lines[i++], ","));
      contacts[j] = new pt(contact[0], contact[1], contact[2]);
      radii[j] = float(lines[i++]);
      float[] initDir = float(split(lines[i++], ","));
      initDirs[j] = new vec(initDir[0], initDir[1], initDir[2]);
    }
    return;
  }
}