/******************************************************************************
 * Ring set processing.
 ******************************************************************************/


boolean debugFastCH = false;
int numFacesShownFastCH = 1;
int numUpdateStepsFastCH = 1;

class DebugFastCHInfo {
  int idr0, idr1, idr2;
  int idp0, idp1, idp2;
  int numSteps;
  int numFacesShown;
  DebugFastCHInfo() {
    idr0 = idr1 = idr2 = -1;
    idp0 = idp1 = idp2 = -1;
    numSteps = 0;
    numFacesShown = 0;
  }
}


/*
 * RingSet class.
 *
 * A ring set is a set of rings (i.e. discritized cicles). We assume that these
 * rings lie on a sphere.
 */
class RingSet {
  pt c;  // the center of the sphere where the ring set lies
  float r;  // the radius of the sphere where the ring set lies
  int nc, np;  // number of rings, and number of points on each ring
  boolean sameRadius;  // whether all rings have the same radius
  pt[] contacts;  // the intersections between the outward normals of rings and the sphere
  float[] radii;  // the radii of rings
  vec[] initDirs;  // the initial directions, one for each ring, used to generate the first point on ring

  pt[][] points;  // the generated points on rings
  pt[] centers;  // the centers of rings, one for each ring

  ArrayList<Triangle> triangles = null;  // triangle mesh with ring vertices
  ArrayList<Triangle> convexHull = null;  // convex hull generated by contacts

  DebugFastCHInfo debugFastCHInfo = new DebugFastCHInfo();  // for debug

  RingSet(pt c, float r) {
    this.c = c;
    this.r = r;
    sameRadius = false;
  }
  
  RingSet(pt c, float r, int nc, int np) {
    this.c = c;
    this.r = r;
    this.nc = nc;
    this.np = np;
    sameRadius = false;
  }
  
  RingSet(pt c, float r, int nc, int np, float rMax) {
    this.c = c;
    this.r = r;
    this.nc = nc;
    this.np = np;
    sameRadius = true;
    radii = new float[1];
    radii[0] = rMax;
  }
  
  void init() {
    if (!sameRadius) {
      radii = new float[nc];
      contacts = generateContactsAndRadii(c, r, nc, radii);
    } else {
      contacts = generateContacts(c, r, nc, radii[0]);
    }
    initDirs = generateInitDirs(c, contacts, nc);
  }
  
  void generatePoints(float attenuation) {
    centers = new pt[nc];
    if (!sameRadius) {
      float[] curRadii = new float[nc];
      for (int i = 0; i < nc; ++i) curRadii[i] = radii[i] * attenuation;
      points = generatePointsForCircles(contacts, curRadii, c, r, initDirs, nc,
                                        np, centers);
    } else {
      float curRadius = radii[0] * attenuation;
      points = generatePointsForCircles(contacts, curRadius, c, r, initDirs, nc,
                                        np, centers);
    }
  }

  void generateTriangleMesh() {
    triangles = generateConvexHull(points, nc, np);
  }

  void generateConvexHullUsingContacts() {
    assert contacts.length >= 4;
    convexHull = generateConvexHull(contacts, nc);
  }


  private Triangle generateThreeRingTriangle(pt[] points0,
                                             pt[] points1,
                                             pt[] points2) {
    int i = 0, j = 0, k = 0;
    vec normal = N(points0[0], points1[0], points2[0]);
    int d0 = dot(normal, V(points0[0], points0[np-1])) > 0 ? -1 : 1;
    int d1 = dot(normal, V(points1[0], points1[np-1])) > 0 ? -1 : 1;
    int d2 = dot(normal, V(points2[0], points2[np-1])) > 0 ? -1 : 1;
    int inext = (i + d0 + np) % np;
    int jnext = (j + d1 + np) % np;
    int knext = (k + d2 + np) % np;
    if (debugFastCH) {
      debugFastCHInfo.idp0 = 0;
      debugFastCHInfo.idp1 = 0;
      debugFastCHInfo.idp2 = 0;
      debugFastCHInfo.numSteps = 1;
    }
    int iprev = (i - d0 + np) % np;
    int jprev = (j - d1 + np) % np;
    int kprev = (k - d2 + np) % np;
    
    while (true) {
      if (debugFastCH &&
          debugFastCHInfo.numFacesShown == numFacesShownFastCH - 1 &&
          debugFastCHInfo.numSteps >= numUpdateStepsFastCH) break;
      boolean noUpdate = true;
      /* TODO: Do we really need to check the two dot products for each while loop? */
      while (dot(normal, V(points2[k], points2[knext])) > 0 ||
             dot(normal, V(points2[k], points2[kprev])) > 0) {  // update c
        if (debugFastCH &&
          debugFastCHInfo.numFacesShown == numFacesShownFastCH - 1 &&
          debugFastCHInfo.numSteps >= numUpdateStepsFastCH) break;
        kprev = k;
        k = knext;
        knext = (knext + d2 + np) % np;
        normal = N(points0[i], points1[j], points2[k]);
        if (noUpdate) noUpdate = false;
        if (debugFastCH) {
          debugFastCHInfo.idp2 = k;
          debugFastCHInfo.numSteps++;
        }
      }
      while (dot(normal, V(points0[i], points0[inext])) > 0 ||
             dot(normal, V(points0[i], points0[iprev])) > 0) {  // update a
        if (debugFastCH &&
          debugFastCHInfo.numFacesShown == numFacesShownFastCH - 1 &&
          debugFastCHInfo.numSteps >= numUpdateStepsFastCH) break;
        iprev = i;
        i = inext;
        inext = (inext + d0 + np) % np;
        normal = N(points0[i], points1[j], points2[k]);
        if (noUpdate) noUpdate = false;
        if (debugFastCH) {
          debugFastCHInfo.idp0 = i;
          debugFastCHInfo.numSteps++;
        }
      }
      while (dot(normal, V(points1[j], points1[jnext])) > 0 ||
             dot(normal, V(points1[j], points1[jprev])) > 0) {  // update b
        if (debugFastCH &&
          debugFastCHInfo.numFacesShown == numFacesShownFastCH - 1 &&
          debugFastCHInfo.numSteps >= numUpdateStepsFastCH) break;
        jprev = j;
        j = jnext;
        jnext = (jnext + d1 + np) % np;
        normal = N(points0[i], points1[j], points2[k]);
        if (noUpdate) noUpdate = false;
        if (debugFastCH) {
          debugFastCHInfo.idp1 = j;
          debugFastCHInfo.numSteps++;
        }
      }
      if (noUpdate) break;
    }
    return new Triangle(i, j, k);
  }

  ArrayList<Triangle> generateThreeRingTriangles() {
    int nt = convexHull.size();  // number of triangles of convex hull
    ArrayList<Triangle> threeRingTriangles = new ArrayList<Triangle>();
    debugFastCHInfo.numFacesShown = 0;
    for (int i = 0; i < nt; ++i) {
      if (debugFastCH && i >= numFacesShownFastCH) break;
      Triangle face = convexHull.get(i);
      Triangle t = generateThreeRingTriangle(points[face.a], points[face.b], points[face.c]);
      Triangle triangle = new Triangle(face.a * np + t.a, face.b * np + t.b, face.c * np + t.c);
      threeRingTriangles.add(triangle);
      if (debugFastCH) {
        debugFastCHInfo.idr0 = face.a;
        debugFastCHInfo.idr1 = face.b;
        debugFastCHInfo.idr2 = face.c;
        debugFastCHInfo.numFacesShown++;
      }
    }
    return threeRingTriangles;
  }

  pt[][] get2DPointArray() {
    return points;
  }

  int getNumGroups() {
    return nc;
  }

  int getNumPointsPerGroup() {
    return np;
  }

  pt[] get1DPointArray() {
    if (points == null) return null;
    pt[] G = new pt[nc * np];
    int k = 0;
    for (int i = 0; i < nc; ++i) {
      for (int j = 0; j < np; ++j) {
        G[k++] = points[i][j];
      }
    }
    return G;
  }

  ArrayList<pt> get1DPointArrayList() {
    if (points == null) return null;
    ArrayList<pt> positions = new ArrayList<pt>();
    for (int i = 0; i < nc; ++i) {
      for (int j = 0; j < np; ++j) {
        positions.add(points[i][j]);
      }
    }
    return positions;
  }

  void showGroups() {
    fill(orange);
    for (int i = 0; i < nc; ++i) {
      show(centers[i], 1);
    }
    fill(green);
    for (int i = 0; i < nc; ++i) {
      arrow(centers[i], V(centers[i], points[i][0]), 2);
    }
    fill(blue);
    for (int i = 0; i < nc; ++i) {
      for (int j = 0; j < np; ++j) {
        show(points[i][j], 2);
      }
    }
    fill(cyan);
    for (int i = 0; i < nc; ++i) {
      for (int j = 0; j < np; ++j) {
        collar(points[i][j], V(points[i][j], points[i][(j + 1) % np]), 1, 1);
      }
    }
    return;
  }
  
  void savePointGroups(String file) {
    String[] lines = new String[2 + 3 * nc];
    int i = 0;
    lines[i++] = str(nc);
    lines[i++] = str(np);
    for (int j = 0; j < nc; ++j) {
      lines[i++] = str(contacts[j].x) + "," + str(contacts[j].y) + "," +
                   str(contacts[j].z);
      lines[i++] = str(radii[j]);
      lines[i++] = str(initDirs[j].x) + "," + str(initDirs[j].y) + "," +
                   str(initDirs[j].z);
    }
    saveStrings(file, lines);
    return;
  }

  void loadPointGroups(String file) {
    String[] lines = loadStrings(file);
    int i = 0;
    nc = int(lines[i++]);
    np = int(lines[i++]);
    contacts = new pt[nc];
    radii = new float[nc];
    initDirs = new vec[nc];
    for (int j = 0; j < nc; ++j) {
      float[] contact = float(split(lines[i++], ","));
      contacts[j] = new pt(contact[0], contact[1], contact[2]);
      radii[j] = float(lines[i++]);
      float[] initDir = float(split(lines[i++], ","));
      initDirs[j] = new vec(initDir[0], initDir[1], initDir[2]);
    }
    return;
  }
}